RANDOM PLANNING/NOTES/PSUEDOCODE/MEETING DOCUMENTATION

# Keegan's stuff
# no edges
# Single Chip, no edges function
# for v in V(chip_parts):
#     for (x,y) in E():
#         if not(x == v or y == v):
#             chipType = id2part[v]['name'].lower()
#             if chipType != 'not':
#                 input1 = id2part[v]['external'][0]['name'].lower()
#                 input2 = id2part[v]['external'][1]['name'].lower()
#                 outV = id2part[v]['external'][2]['name']
#                 d = logicparse(input1 + ' ' + chipType + ' ' + input2, outlabel=outV)
#                 d.draw()
#             else:
#                 input1 = id2part[v]['external'][0]['name']
#                 outV = id2part[v]['external'][1]['name']
#                 d = logicparse(chipType + ' ' + input1, outlabel=outV)
#                 d.draw()
#

'''PSUEDOCODE'''

# for each (external facing) output in a chip:
    # if all parts are primitive gates:
        # determine the logic equation to be fed to logic parser -
            #


''' READ THIS FOR AN UPDATE 4/30/2021 '''

# What we have :
  - the right topologl order of nodes in the graph
  - a way to draw primitive gates that are sequentially connected via logicparse
  - a way to combine multiple gate drawings into one drawing object
    - which can be further added to other drawings if we override the class to specify anchors (where the next drawn element should start from)

# What we don't have :
  - time
  - understanding of how to subclass schemdraw elements (it is a complex library not really tailored to our needs)

# What we can hope to accomplish right now ... :
  - draw any chip with n outputs iff all parts are primitive gates

# ... given the assumption :
  - only primitive gates (not, and, xor, etc.)
  - we can learn what we need from schemdraw in a day
    !!!!! figuring out how to logicparse multiple outputs !!!!!!

# What we need :
  - a function to parse the topologically sorted list of parts:
    - it should correctly:
      - write an equation to be fed to logicparse
      - write multiple equations to be fed to logicparse, for multiple outputs
        - what if these equations have mutual terms ? how would we then process drawings for multiple outputs ?
      - process the drawings from logicparse and correctly concatenate into one drawing to be returned.








''' THE REST IS RANDOM FROM PRIOR TO 4/30/2021'''

#
# from nand2tetris_hdl_parser import parse_hdl
# import re
# from topsort import Chip_Graph

'''
PSUEDOCODE

# id should be something that can be determined even when working with dict
    # therefore concatenate pin names to create id
    # then when iterating through id2part, can easily access adjacency list
    # without having access to an autogenerated key

# adj list will look like { <String> : [<Strings>] } -> { id : [ids with edge] }
    # can get dict representation of part from id2part dict
        # looks like { <String> : {<Dict>} } -> { id : parser representation of part }

# for each vertex in graph (part):
    # assign unique key name to part
    # assign part's dictionary representation as value in id2part

# for each key in id2part:
    # get list parts adjacent nodes
    # assign list of adjacent part dictionaries to part's id in id2adj
'''

#
# infile = open("Xor.hdl","r").read()
# hdl = parse_hdl(infile) # Teddy's parser, returns dictionary representation of Chip
#
# chip_keys = [key for key in hdl.keys()] # Native to Teddy's parser
# chip_parts = hdl[chip_keys[3]] # list of dict representation of parts
#
# id2part = {} # Global dictionary that allows access to dictionary representation of part from it's id
#
# def V(parts):
#     '''
#         this function returns a list of vertices comprising all the parts in the chip
#             - the parts are represented by their ids (1..n) which are guarunteed unique
#             - as well as their concatenated pin names
#             - it also populates the id2part dictionary with the numerical ids as keys and the parts as values
#             *** this function is automatically called by E, there is no need to call it ***
#     '''
#
#     V = []
#     pc = 0
#
#     for p in parts:
#         concat = str(p['name'])
#         for n in p['external']:
#             concat += str(n['name'])
#         p['concat'] = concat
#         p['id'] = pc
#
#         V.append(pc)
#         id2part[pc] = p
#
#         pc += 1
#
#     return V
# def E():
#     '''
#     this function returns a list of tuples representing the edges found in the graph
#         - it may not include every vertex in it, only vertices which have an outgoing edge
#     '''
#
#     edges = []
#     parts = [id2part[p] for p in V(chip_parts)]
#
#     for p in parts:
#
#         o = indexOfOut(p)
#         pc = 0
#
#         outputs = []
#         for pin in p['external']:
#             if pc >= o:
#                 outputs.append(pin['name'])
#             pc += 1
#
#         for pp in parts:
#             if pp['id'] == p['id']:
#                 continue
#
#             o = indexOfOut(pp)
#             ppc = 0
#
#             inputs = []
#             for pin in pp['external']:
#                 if ppc < o:
#                     inputs.append(pin['name'])
#                 ppc += 1
#
#             for a in outputs:
#                 for b in inputs:
#                     if a == b:
#                         e = [p['id'], pp['id']]
#                         if tuple(e) not in edges:
#                             edges.append(tuple(e))
#
#
#
#     return edges
# def indexOfOut(part):
#     '''
#     helper function to distinguish between external input and output pins
#         *** an edge must be directed from one part's output to another part's input ***
#     '''
#
#     idx = 0
#     pins = part['internal']
#     for d in pins:
#         if d['name'] != 'out':
#             idx += 1
#
#     return idx
#
# print('list of edges as tuples: ', E())
# print('no. of edges: ', len(E()))
# print('list of vertices: ', V(chip_parts))
# print('length of V', len(V(chip_parts)))
# print(id2part)
#
# print()
#
# g = Chip_Graph(len(V(chip_parts))) # number of vertices
#
# for tpl in E():
#     g.add_edge(tpl[0], tpl[1])
#
# print(g.topological_sort())
#
# for s in g.topological_sort():
#     print(id2part[s]['concat'])
#
# # # print([i['name'] for i in id2part.keys()])
# # # test case
# # # listOfTuples = [("Not1", "And1"), ("Not1", "And3"),("Not2", "And3"), ("Not2", "Or1"), ("And1", "Or2"), ("Or2", "Or1")]
# # listOfTuples = E()
# #
# # # replace len(listOfTuples) with the number of vertices in the graph
# # g = Chip_Graph(len(V(chip_parts))) # number of vertices
# # for tpl in listOfTuples:
# #     g.add_edge(tpl.first, tpl.second)
# #
# # # chips = []
# # # for i in listOfTuples: # listOfTuples should be the adjacency list
# # #     g.add_edge(i[0], i[1])
# # #     if not i[0] in chips:
# # #         chips.append(i[0])
# # #         if not i[1] in chips:
# # #             chips.append(i[1])
# # # print(chips)
# #
# # s = g.topological_sort()
# # # for chip in s:
# # #     print(s)
# # print("Topological Sort of the graph: ", g.topological_sort())


# # print([i['name'] for i in id2part.keys()])
# # test case
# # listOfTuples = [("Not1", "And1"), ("Not1", "And3"),("Not2", "And3"), ("Not2", "Or1"), ("And1", "Or2"), ("Or2", "Or1")]
# listOfTuples = E()
#
# # replace len(listOfTuples) with the number of vertices in the graph
# g = Chip_Graph(len(V(chip_parts))) # number of vertices
# for tpl in listOfTuples:
#     g.add_edge(tpl.first, tpl.second)
#
# # chips = []
# # for i in listOfTuples: # listOfTuples should be the adjacency list
# #     g.add_edge(i[0], i[1])
# #     if not i[0] in chips:
# #         chips.append(i[0])
# #         if not i[1] in chips:
# #             chips.append(i[1])
# # print(chips)
#
# s = g.topological_sort()
# # for chip in s:
# #     print(s)
# print("Topological Sort of the graph: ", g.topological_sort())

'''
Test for Derik -

input file -- DMux.hdl

    CHIP DMux {
        IN in, sel;
        OUT a, b;

        PARTS:
        // Put your code here:
        Not(in=sel, out=notSel);
        And(a=in, b=notSel, out=a);
        And(a=in, b=sel, out=b);
    }

let G (adj list) for DMux look like --

{'NotselnotSel' : ['AndinnotSela'], 'AndinnotSela' : [<empty>], 'Andinselb' : [<empty>]}

'''


'''
Meeting 4/8 -

Go thru structure and Teddys parser
Questions about getting adjacency list -> is it just a dfs starting from each vertex with indegree = 0?
Top sort needs to be parallel with functions that convert from dictionary structure to schemdraw Object
    only a few weeks left (!)

-> can use dictionaries as values, assign unique id as key -> to store list of parts for chip
->

'''


'''
Goal: Chip and parts as Objects -> Adjacency Matrix / Adjacency List

Chip Object Structure:

    pub struct Chip {
        pub name: String,
        pub inputs: Vec<Pin>,
        pub outputs: Vec<Pin>,
        pub parts: Vec<Part>,
    }

Part Object Structure:

    pub struct Part {
        pub name: String,
        pub internal: Vec<Pin>,
        pub external: Vec<Pin>,
    }

'''


'''
SCRATCH

# def G(parts):
#     '''
#         this function constructs a graph and returns it's adjacency list representation
#             - the parts and their list of adjacent parts are represented by their ids
#             - if a part's pin name is included in another part's pin name, I will call it an edge
#                 - is this problematic?
#
#     '''
#     id2edges = {}
#     for v in V(parts): # v looks like 'NotpnotP'
#         E = [] # edges for a particular v, should be ids
#         p = id2part[v]
#         pins = p['external']
#         for vv in V(parts):
#             if v == vv:
#                 continue
#             else:
#                 pp = id2part[vv] # dict rep
#                 ppins = pp['external'] # list of external pins
#                 for n in pins:
#                     for nn in ppins:
#                         if n['name'] == nn['name'] and vv not in E:
#                             E.append(vv)
#
#         id2edges[v] = E
#
#     return id2edges

# print(chip_parts[0])
# print()
# print(chip_parts[1])
# print()
# print(chip_parts[2])
# print()
# print(chip_parts[3])
# #
# # print(id2part['NotpnotP'])
# # print()
# # print(id2part['NotqnotQ'])
#
# # print(G)

# def identify(part):
#     '''
#         this function returns the id of a part from its dictionary representation
#             - the id is formed by concatenating external pin names to the name of the gate
#             - use this function when working with dict representation of parts and need access to it's id
#     '''
#     id = str(part['name'])
#     for n in part['external']:
#         id += str(n['name'])
#     return id

print(E(), len(E()))
#
# print(chip_parts, '\n\n')
# print(E(chip_parts))
# print(indexOfOut({'name': 'Not', 'internal': [{'name': 'in', 'start': 0, 'end': 0}, {'name': 'out', 'start': 0, 'end': 0}], 'external': [{'name': 'in', 'start': 1, 'end': 1}, {'name': 'out', 'start': 1, 'end': 1}]}))
# print()
# print(indexOfOut({'name': 'And', 'internal': [{'name': 'a', 'start': 0, 'end': 0}, {'name': 'b', 'start': 0, 'end': 0}, {'name': 'out', 'start': 0, 'end': 0}], 'external': [{'name': 'notP', 'start': 0, 'end': 0}, {'name': 'notT', 'start': 0, 'end': 0}, {'name': 'notPT', 'start': 0, 'end': 0}]}))


'''
